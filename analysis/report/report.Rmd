---
title: "Comparison of WHO and The Economist Excess Mortality impact on vaccine deaths averted"
author:
  - Greg Barnsley:
      email: g.barnsley@imperial.ac.uk
      institute: [ICL]
      correspondence: true
institute:
  - ICL: Imperial College London
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
    word_document
bibliography: references.bib
params:
  gather_raw_data: FALSE
  parallel_: FALSE
  generate_model_fits: FALSE
---

<!-- The following code chunk defines some general settings how code chunks should behave. -->

```{r setup, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  message = FALSE,
  echo = FALSE,
  comment = "#>",
  fig.path = "../figures/",
  dpi = 300
)

library(tidyverse)
library(lubridate)
library(readxl)
```

<!-- The actual document text starts here: -->

# Introduction

<!-- do last then update description and upload to github -->

# Comparison of Estimates

```{r load Economist}
econ_raw_file_path <- file.path(here::here(), "analysis/data/raw_data/economist_raw.csv")
if(params$gather_raw_data){
  #save to the raw_data_folder
  download.file("https://raw.githubusercontent.com/TheEconomist/covid-19-the-economist-global-excess-deaths-model/baca4ff7f77b031de8e1b0f5f73eaf1ca8e50998/output-data/export_country.csv", econ_raw_file_path)
}
#load raw version from data_raw
econ_df <- read_csv(econ_raw_file_path)
#process to get what we need, date + iso3c + combined median & true value
econ_df <- econ_df %>% 
  mutate(economist_estimated = is.na(daily_excess_deaths)) %>% 
  select(date, iso3c, estimated_daily_excess_deaths, economist_estimated) %>% 
  rename(economist_excess_deaths = estimated_daily_excess_deaths)
```

```{r load WHO}
who_raw_file_path <- file.path(here::here(), "analysis/data/raw_data/who_raw.zip")
if(params$gather_raw_data){
  #save to the raw_data_folder
  download.file("https://cdn.who.int/media/docs/default-source/world-health-data-platform/covid-19-excessmortality/2022-03-25_covid-19_gem.zip", who_raw_file_path)
}
#extract files
unzip(who_raw_file_path, "WHO_COVID_Excess_Deaths_EstimatesByCountry.xlsx", exdir = here::here("temp"))
#load raw version from unzipped
who_df <- read_xlsx(here::here("temp/WHO_COVID_Excess_Deaths_EstimatesByCountry.xlsx"),
                    sheet = "Country by year and month", skip = 12)
#remove temp folder
unlink(here::here("temp"), force = TRUE, recursive = TRUE)
#process to get what we need, date + iso3c + excess
who_df <- who_df %>% 
  mutate(who_estimated = type == "Predicted",
         date = as.Date.character(paste0(as.character(year), "-", as.character(month), "-01"))) %>% 
  select(date, iso3, excess.mean, who_estimated) %>% 
  rename(iso3c = iso3, who_excess_deaths = excess.mean) %>% 
  #Scale the December value so that its representative up to 2021-12-08
  mutate(
    who_excess_deaths = if_else(
      date == "2021-12-01",
      who_excess_deaths*(8/31),
      who_excess_deaths
    )
  )
```

```{r combine WHO ECON}
#they are in different formats atm so we will convert economist into monthly
econ_df <- econ_df %>% 
  group_by(iso3c) %>% 
  arrange(iso3c, date) %>% 
  #assume daily econo estimate date is the middle date for the week
  #first get the first day of the week for that date
  mutate(week_start_date = floor_date(date, "week"),
         #only update this there's a whole week between, this way we still apply the final estimate
         date = if_else(diff(c(min(week_start_date) - 7, week_start_date)) == 7,
                        week_start_date, date)) %>% 
  complete(date = seq(min(date), max(week_start_date) + 7, 1)) %>% 
  fill(economist_excess_deaths, economist_estimated, .direction = "down") %>% 
  #remove values that fall outside our fitting period
  filter(date > "2019-12-31" & date <= "2021-12-08") %>% 
  #now group into months
  mutate(month = month(date),
         year = year(date)) %>% 
  group_by(iso3c, year, month) %>% 
  summarise(economist_excess_deaths = sum(economist_excess_deaths),
            economist_estimated = any(economist_estimated),
            date = min(date), .groups = "drop") %>% 
  select(!c(month, year))
#now only keep countries in both
in_both <- intersect(intersect(econ_df$iso3c, who_df$iso3c), squire::population$iso3c)
combined_df <- econ_df %>% 
  filter(iso3c %in% in_both) %>% 
  full_join(
    who_df %>% 
      filter(iso3c %in% in_both)
  ) %>% #add pops %>% 
  filter(!iso3c %in% c("CHN")) %>% 
  left_join(
    squire::population %>% 
      group_by(iso3c) %>% 
      summarise(
        pop = sum(n)
      )
  )
#save to data folder
write_csv(combined_df %>% 
            rename(month = date),
          file.path(here::here("analysis/data/derived_data/combined_estimates.csv")))
```

```{r totals numeric}
totals_overall <- combined_df %>% 
  summarise(
    across(
      c(economist_excess_deaths, who_excess_deaths),
      ~format(signif(sum(.x), 4), big.mark = ",")
    )
  ) %>% 
  as.list()

totals_2021 <- combined_df %>% 
  filter(date >= "2020-12-01") %>% 
  summarise(
    across(
      c(economist_excess_deaths, who_excess_deaths),
      ~format(signif(sum(.x), 4), big.mark = ",")
    )
  ) %>% 
  as.list()
```

```{r totals plot}
#only interested in values where one or the other are estimated
est_total_df <- combined_df %>% 
  filter(economist_estimated | who_estimated) %>% 
  group_by(iso3c) %>% 
  summarise(
    across(c(economist_excess_deaths, who_excess_deaths),
           ~sum(.x)),
    pop = pop[1]
  )

total_comp_df <- est_total_df %>% 
  mutate(
           economist_excess_deaths = economist_excess_deaths/pop * 1000,
           who_excess_deaths = who_excess_deaths/pop * 1000,
           label = if_else(
              who_excess_deaths > economist_excess_deaths + 2.5 |
                who_excess_deaths < economist_excess_deaths -3,
              countrycode::countrycode(iso3c, origin = "iso3c", destination = "country.name"),
              ""
            )
           )
total_comp_plot <- ggplot(total_comp_df) +
  geom_abline(intercept = 0, slope = 1, alpha = 0.5, linetype = "dashed") + 
  geom_smooth(aes(x = economist_excess_deaths, y = who_excess_deaths), method = "lm", fullrange = TRUE, level = 0, colour = "black") + 
  geom_point(aes(x = economist_excess_deaths, y = who_excess_deaths, colour = squire.page::get_WHO_region(iso3c)), alpha = 0.9) + 
  geom_text(aes(x = economist_excess_deaths, y = who_excess_deaths, label = label), nudge_y = -0.25) +
  ggpubr::theme_pubr() + 
  labs(x = "Economist Estimated Excess Mortality per 1000",
       y = "WHO Estimates Excess Mortality per 1000",
       colour = "WHO Region:")

new_gradient <- lm(who_excess_deaths ~ economist_excess_deaths, total_comp_df %>% 
  filter(!iso3c %in% c("DJI", "IRQ", "SDN")))$coefficients[2]

#save to figures
ggsave(here::here("analysis/figures/01_total-comparison.pdf"), total_comp_plot)
```

```{r monthly plot}
monthly_comp_plot <- combined_df %>% 
  group_by(date) %>% 
  summarise(
    across(
      c(economist_excess_deaths, who_excess_deaths),
      ~sum(.x)
    )
  ) %>% 
  mutate(
    ratio = economist_excess_deaths - who_excess_deaths
  ) %>% 
  ggplot() +
  geom_step(aes(x = date, y = ratio)) + 
  ggpubr::theme_pubr() + 
  labs(x = "Date", y = "Monthly Difference between Economist Estimate\nand WHO Estimate") + 
  scale_y_continuous(labels = scales::comma)

ggsave(here::here("analysis/figures/02_monthly-comparison.pdf"), monthly_comp_plot)
```

To briefly compare the WHO estimates to the estimates from The Economist (used 
in the vaccine impact paper) we first align the format of the two datasets.
Given the weekly basis for the Economists' estimates we aggregate these into a
monthly format. Comparing across the average estimates all countries and 
territories that are in both datasets and included in the vaccine impact paper 
(i.e. excluding China and countries with populations less than 90,000), the 
WHO gives `r totals_overall$who_excess_deaths` compared to
`r totals_overall$economist_excess_deaths` from The Economist. Limiting this
to the year 2021 gives us `r totals_2021$who_excess_deaths` compared to
`r totals_2021$economist_excess_deaths`.

```{r, fig.cap = "Comparison of Excess Mortality Estimates per country per 1,000 people. The grey dashed line repesents the gradient of equality and the black line the least squares estimate of the gradient."}
print(total_comp_plot)
```


Comparing this across countries in figure 1, there is a strong positive 
correlation between the two sets of estimates, as to be expected. However, 
there is a trend for The Economist to estimate higher mortality than the WHO,
evidenced by comparing the line of best fit to the slope of equality. There are
several outliers in the this comparison, notably Djibouti, Iraq, and Sudan
where The Economist model estimates very high mortality, higher than any other 
country included (per capita). Iraq, and Sudan were also outliers in the 
vaccine-impact paper as the model could recreate the death curves of neither. 
Excluding these from the line of best fit estimation, gives a gradient of 
`r new_gradient`.

```{r, fig.cap = "Comparison of Global Monthly Excess Mortality between the two estimates."}
print(monthly_comp_plot)
```

Figure 2, taken over all excess mortality (real or estimated) shows a temporal
aspect to the difference between the estimates. With roughly two distinct peaks 
(meaning that the Economist is estimating higher than the WHO) one over the first
half of 2020 and another in the last half of 2021.

# Impact on Deaths Averted

```{r get deaths averted}
if(params$gather_raw_data){
  #calculate deaths averted from the vaccine impact repo
  #we are processing this data because otherwise it would be many largish files
  map_dfr(unique(combined_df$iso3c), function(iso3c){
    dir.create(here::here("temp"))
    exists <- tryCatch(
    walk(c("Baseline_", "No%20Vaccines_"), function(file){
      download.file(
        paste0("https://github.com/mrc-ide/covid-vaccine-impact-orderly/blob/main/data/excess_mortality/counterfactual_data/", 
           file, iso3c, ".Rds?raw=true"), here::here(paste0("temp/",file, ".Rds")),
        mode = "wb"
      )
    }),
    error = function(e){NULL})
    if(!is.null(exists)){
      base <- readRDS(here::here("temp/Baseline_.Rds"))
    cf <- readRDS(here::here("temp/No%20Vaccines_.Rds"))
    unlink(here::here("temp"), force = TRUE, recursive = TRUE)
    tibble(
      date = base$date,
      replicate = base$replicate,
      deaths_averted = cf$deaths - base$deaths,
      deaths = base$deaths,
      iso3c = base$iso3c,
      year = year(base$date),
      month = month(base$date)
    ) %>%
      group_by(replicate, year, month) %>% 
      summarise(
        deaths_averted = sum(deaths_averted),
        deaths = sum(deaths),
        iso3c = iso3c[1],
        date = min(date),
        .groups = "drop"
        ) %>% 
      select(iso3c, replicate, date, deaths, deaths_averted)
    } else {
      NULL
    }
  }) %>% 
    saveRDS(here::here("analysis/data/raw_data/excess_mortality.Rds"))
  #now get the reported deaths data
  map_dfr(unique(combined_df$iso3c), function(iso3c){
    dir.create(here::here("temp"))
    exists <- tryCatch(
    walk(c("Baseline_", "No%20Vaccines_"), function(file){
      download.file(
        paste0("https://github.com/mrc-ide/covid-vaccine-impact-orderly/blob/main/data/reported_deaths/counterfactual_data/", 
           file, iso3c, ".Rds?raw=true"), here::here(paste0("temp/",file, ".Rds")),
        mode = "wb"
      )
    }),
    error = function(e){NULL})
    if(!is.null(exists)){
    base <- readRDS(here::here("temp/Baseline_.Rds"))
    cf <- readRDS(here::here("temp/No%20Vaccines_.Rds"))
    unlink(here::here("temp"), force = TRUE, recursive = TRUE)
    tibble(
      date = base$date,
      replicate = base$replicate,
      deaths_averted = cf$deaths - base$deaths,
      deaths = base$deaths,
      iso3c = base$iso3c,
      year = year(base$date),
      month = month(base$date)
    ) %>%
      group_by(replicate, year, month) %>% 
      summarise(
        deaths_averted = sum(deaths_averted),
        deaths = sum(deaths),
        iso3c = iso3c[1],
        date = min(date),
        .groups = "drop"
        ) %>% 
      select(iso3c, replicate, date, deaths, deaths_averted)
    } else {
      NULL
    }
  }) %>% 
    saveRDS(here::here("analysis/data/raw_data/reported_deaths.Rds"))
}
#load data
deaths_averted <- readRDS(here::here("analysis/data/raw_data/excess_mortality.Rds")) %>% 
  mutate(type = "excess") %>% 
  rbind(
    readRDS(here::here("analysis/data/raw_data/reported_deaths.Rds")) %>% 
      mutate(type = "reported")
  ) %>% 
  filter(!is.na(date)) %>% 
  filter(date > "2019-12-31") %>%
  mutate(date = floor_date(date, "month")) %>%  #ensure this is in terms of whole months
  #drop ones with no vaccinations (i.e. no deaths averted)
  group_by(iso3c) %>% 
  filter(sum(deaths_averted) != 0) %>% 
  group_by(iso3c, date, type)
```

```{r get vaccine data}
#Raw data unavailable from Unicef dashboard https://www.unicef.org/supply/covid-19-vaccine-market-dashboard
simplify_vaccines <- function(x){
  case_when(
      x %in% c("Pfizer/BioNTech", "Moderna") ~ "mRNA",
      x %in% c("Abdala", "Novavax", "ZF2001", "Soberana02", "Soberana Plus", "Razi Cov Pars", "SpikoGen", "EpiVacCorona", "Medigen", "Abdala (Subunit like novavax)", "Anhui ZL (Recombinant Platform)") ~ "Subunit",
      x %in% c("Oxford/AstraZeneca", "Sputnik V", "Sputnik Light", "CanSino", "Covishield") ~ "Adenovirus",
      x %in% c("Sinopharm/Wuhan", "Sinopharm/Beijing", "Sinovac", "Covaxin", "COVIran Barekat", "FAKHRAVAC", "QazVac", "Turkovac", "KoviVac/Chumakov") ~ "Whole Virus",
      TRUE ~ x,
    )
}
dominant_vaccines <- readRDS(here::here("analysis/data/raw_data/dominant_vaccines.Rds"))%>% 
  transmute(
    iso3c = countrycode::countrycode(country, "country.name", "iso3c"),
    #reduce to types
    dominant_vaccine = simplify_vaccines(dominant)
  )
if(params$gather_raw_data){
  url <- xml2::read_html("https://github.com/owid/covid-19-data/tree/master/public/data/vaccinations/country_data")
  ctries <- rvest::html_text(rvest::html_nodes(url, ".js-navigation-open.Link--primary"))
  links <- paste0("https://raw.githubusercontent.com/owid/covid-19-data/master/public/data/vaccinations/country_data/", ctries)
  links <- urltools::url_encode(links)
  dat <- lapply(links, read.csv)
  present_vaccines <- data.frame("country" = gsub(".csv","", ctries, fixed = TRUE),
                 "vaccines" = unlist(lapply(dat, function(x){tail(x$vaccine,1)}))) %>%
    mutate(
      country = case_when(
        country %in% c("England", "Northern Ireland", "Scotland", "Wales") ~ "United Kingdom",
        country == "Timor" ~ "Timor Leste",
        TRUE ~ country
      ),
      country = if_else(
        country == "Kosovo",
        "XKX",
        countrycode::countrycode(country, origin = "country.name", destination = "iso3c")
      )
    ) %>%
    filter(country %in% dominant_vaccines$iso3c) %>%
    rename(iso3c = country) %>%
    unique() %>%
    group_by(iso3c) %>%
    summarise(
      vaccines = paste0(vaccines, collapse = ", ")
    )
  saveRDS(present_vaccines, here::here("analysis/data/raw_data/owid_vaccine_usage.Rds"))
  rm(url, ctries, links, dat)
} else {
  present_vaccines <- readRDS(here::here("analysis/data/raw_data/owid_vaccine_usage.Rds"))
}
#add missing values
present_vaccines <- present_vaccines %>%
  rbind(
    tibble(
      iso3c = c("GUF", "GLP", "MTQ", "MYT", "REU"),
      vaccines = present_vaccines %>%
        filter(iso3c == "FRA") %>%
        pull(vaccines)
    )
  ) %>%
  rbind(
    vaccines = present_vaccines %>%
      filter(iso3c == "GBR") %>%
      mutate(iso3c = "CHI")
  ) %>%
  rbind(
    tibble(
      iso3c = c("GUM", "FSM", "PRI", "VIR"),
      vaccines = c("Pfizer/BioNTech, Moderna, Johnson&Johnson",
                   "Moderna, Johnson&Johnson",
                   "Pfizer/BioNTech, Moderna, Johnson&Johnson",
                   "Pfizer/BioNTech, Moderna")
    )
  )

#split into distinct categories
vaccine_types <- unique(unlist(str_split(unique(present_vaccines$vaccines), ", ")))
#simplify to types
vaccine_cat <- simplify_vaccines(vaccine_types)
unique_cat <- unique(vaccine_cat)
names(unique_cat) <- unique_cat
#reduce
present_vaccines <- present_vaccines %>%
  select(!vaccines) %>%
  cbind(
    map_dfc(unique_cat, function(category){
      reduce(vaccine_types[vaccine_cat == category],
             function(curr, new_vaccine_type){
               curr + str_detect(present_vaccines$vaccines, new_vaccine_type) > 0
             },
             .init = FALSE
      )
    })
  )
rm(vaccine_types, vaccine_cat, unique_cat)

#Also load when variant timings start, no source available generated when model
#fitted to covariants data
variant_timings <- readRDS(here::here("analysis/data/raw_data/variant_characteristics.rds")) %>% 
  map_dfr(function(country) map_dfc(country, ~.x$start_date), .id = "iso3c") %>% 
  transmute(
    iso3c = iso3c,
    across(!iso3c,
           ~as.numeric(.x),
           .names = "start_date_{col}")
  )

#start_date of epidemic (rough for now)
epidemic_start_dates <- deaths_averted %>% 
  group_by(iso3c, replicate, type) %>% 
  filter(deaths > 0) %>% 
  summarise(
    start_date_epidemic = as.numeric(min(date)),
    .groups = "drop"
  )

#well assume this is the first non zero deaths averted in any replicate/type of fit
vaccination_start_dates <- deaths_averted %>% 
  group_by(iso3c) %>% 
  filter(deaths_averted > 0) %>% 
  summarise(start_date_vaccination = min(date))

#again no source, based on formattted OWID data
vaccinations_total <- readRDS(here::here("analysis/data/raw_data/vacc_inputs.rds")) %>% 
  map_dfr(~tibble(first_doses = sum(.x$max_vaccine), second_doses = tail(.x$dose_ratio, 1)*sum(.x$max_vaccine)), .id = "iso3c")
```


```{r fit lme to excess}
set.seed(100100)
#determine the first date of deaths averted in any type, i.e. when vaccination starts,
#we'll use this to get deaths over vaccination period, and deaths non vaccine period
#main issue cannot capture variation in VE very well

age_baseline_ifr <- nimue:::default_probs()$prob_hosp * 
        (nimue:::default_probs()$prob_severe * nimue:::default_probs()$prob_severe_death_treatment + 
        (1-nimue:::default_probs()$prob_severe) * nimue:::default_probs()$prob_non_severe_death_treatment)
##used to calculate the baseline IFR for the demographic

fitting_data <- deaths_averted %>% 
  group_by(iso3c, replicate, type) %>% 
  left_join(vaccination_start_dates, by = "iso3c") %>%
  mutate(vaccine_period = date >= start_date_vaccination) %>%
  #summarise to get totals
  summarise(deaths_averted = sum(deaths_averted),
            deaths_vaccine = sum(deaths[vaccine_period]),
            deaths_non_vaccine = sum(deaths[!vaccine_period]),
            start_date_vaccination = as.numeric(start_date_vaccination[1]),
            .groups = "drop") %>% 
  #add extra data:
  #population
  left_join(
    squire::population %>% 
      group_by(iso3c) %>% 
      summarise(pop = sum(n)), 
    by = "iso3c"
  ) %>% 
  group_by(iso3c) %>%
  #IFR at t0
  mutate(
    baseline_ifr =
       weighted.mean(
        age_baseline_ifr,
        squire::population[squire::population$iso3c == iso3c[1],"n"]
       )
  ) %>% 
  #hopsital and ICU capacity
  mutate(
    hosp_beds = squire::get_healthcare_capacity(
      squire::population$country[squire::population$iso3c == iso3c[1]][1]
    )$hosp_beds,
    ICU_beds = squire::get_healthcare_capacity(
      squire::population$country[squire::population$iso3c == iso3c[1]][1]
    )$ICU_beds
  ) %>% 
  ungroup() %>% 
  #Regions
  mutate(
    income_group = squire.page:::get_income_group(iso3c),
    who_region = squire.page:::get_WHO_region(iso3c)
  ) %>% 
  #add vaccine type data
  left_join(dominant_vaccines, by = "iso3c") %>%
  mutate(
    dominant_vaccine = if_else(is.na(dominant_vaccine), "Missing", dominant_vaccine)
  ) %>% 
  left_join(present_vaccines, by = "iso3c") %>%
  #epidemic and variant start dates
  left_join(variant_timings, by = "iso3c") %>%
  left_join(epidemic_start_dates, by = c("iso3c", "replicate", "type")) %>%
  #vaccination counts
  left_join(vaccinations_total, by = "iso3c") %>% 
  #make per capita
  mutate(across(
    c(deaths_averted, deaths_vaccine, deaths_non_vaccine, first_doses, second_doses),
    ~.x/pop)
    )

#scale standardise variables (potentially standardise in each country?)
normal_vars <- c("deaths_averted", "deaths_vaccine", "deaths_non_vaccine", 
                 "hosp_beds", "ICU_beds", "baseline_ifr", "start_date_vaccination",
                 "start_date_Delta", "start_date_Omicron", "start_date_epidemic",
                 "first_doses", "second_doses")
means <- fitting_data %>% 
  ungroup() %>% 
  summarise(
    across(all_of(normal_vars), mean)
  ) %>% 
  as.list()
vars <- fitting_data %>% 
  ungroup() %>% 
  summarise(
    across(all_of(normal_vars), var)
  ) %>% 
  as.list()

standardise_df <- function(data){
  force(normal_vars)
  force(means)
  force(vars)
  names(normal_vars) <- normal_vars
  data <- data %>%
    mutate(across(all_of(normal_vars),
                ~.x,
                .names = "{.col}_original")) %>%
    select(!all_of(normal_vars)) %>% 
    cbind(map_dfc(normal_vars, function(variable){
  (data[[variable]] - means[[variable]])/sqrt(vars[[variable]])
}))
}
unstandardise_deaths_averted <- function(x){
  force(means)
  force(vars)
  (x * sqrt(vars$deaths_averted)) + means$deaths_averted
}
fitting_data <- standardise_df(fitting_data)

#evalute performance via cross validation
N_valid <- 10
#split the reported deaths and excess equally and ensure groups are equal sizes
partioned_data <- fitting_data %>% 
  ungroup() %>% 
  select(iso3c, replicate, type) %>% 
  unique() %>% 
  group_by(iso3c, type) %>% 
  #now split the replicates evenly across the N_valid comparments
  mutate(
    group = {
      #get the sizes
      sizes <- diff(round(seq(0, length(replicate), length.out = N_valid + 1)))
      #generate these as actual values
      map(seq_along(sizes), ~rep(.x, sizes[.x])) %>% 
        unlist() %>% 
        #randomly reorder
        sample(size = length(replicate), replace = FALSE)
    }
  ) %>%  #add these back to the fitting frame
  right_join(
    fitting_data
  )

if(params$parallel_){
    future::plan(future::multisession())
  map_func <- function(.x, .f){
    furrr::future_map(.x, .f)
  }
} else {
  map_func <- function(.x, .f){
    map(.x, .f)
  }
}

#define error
error_func <- function(target, prediction){
  sqrt(sum((target - prediction)^2))
}

tuning_parameters <- expand_grid(
  include_iso3c = FALSE,
  learning_rate = c(0.1, 0.01, 0.001),
  WHO = c(TRUE, FALSE),
  daily_deaths = c(TRUE, FALSE)
) %>% transpose()

generate_formula <- function(include_iso3c, WHO){
  temp_df <- fitting_data[1:2,]
  remove_vars <- c("pop", "replicate", "type")
  if(!include_iso3c){
    remove_vars <- c(remove_vars, "iso3c")
  }
  if(!WHO){
    remove_vars <- c(remove_vars, "who_region")
  }
  DF2formula(temp_df %>% select(!any_of(remove_vars)) %>% 
               select(!contains("_original")) %>% 
               #set target to be at the front
               relocate(deaths_averted))
}

errors <- map_func(seq_len(N_valid), function(test_index){
  train <- partioned_data %>% filter(group == test_index)
  test <- partioned_data %>% filter(group != test_index & iso3c %in% train$iso3c) #remove countries we've not trained on
  
  if(params$generate_model_fits){
    fits <- map_func(tuning_parameters, function(tuning_params){
      if(tuning_params$daily_deaths){
        train <- train %>% 
          mutate(deaths_non_vaccine = deaths_non_vaccine/(start_date_vaccination_original - start_date_epidemic_original),
                 deaths_vaccine = deaths_vaccine/(as.numeric(as.Date("2021-12-08")) - start_date_vaccination_original)
          )
      }
      agtboost::gbt.train(
        y = train$deaths_averted,
        x = model.matrix(generate_formula(tuning_params$include_iso3c, tuning_params$WHO), train), learning_rate = tuning_params$learning_rate
      )
    })
    #save files
    walk(
      seq_along(tuning_parameters), ~agtboost::gbt.save(
        fits[[.x]],
        here::here(paste0("analysis/data/derived_data/fits/agt_", paste0(names(tuning_parameters[[.x]]), collapse = "_"), ".agtb"))
        )
    )
  } else {
    fits <- map(
      seq_along(tuning_parameters), ~agtboost::gbt.load(
        here::here(paste0("analysis/data/derived_data/fits/agt_", paste0(names(tuning_parameters[[.x]]), collapse = "_"), ".agtb"))
        )
    )
  }
  
  #generate predictions
  predicted_agt <- map(seq_along(fits), function(x){
      if(tuning_parameters[[x]]$daily_deaths){
        test <- test %>% 
          mutate(deaths_non_vaccine = deaths_non_vaccine/(start_date_vaccination_original - start_date_epidemic_original),
                 deaths_vaccine = deaths_vaccine/(as.numeric(as.Date("2021-12-08")) - start_date_vaccination_original)
          )
      }
    predict(fits[[x]], model.matrix(generate_formula(tuning_parameters[[x]]$include_iso3c, tuning_parameters[[x]]$WHO), test))
  })
  
  #remove to save on RAM
  rm(fits)
  
  #unstandardise
  predicted_agt <- map(predicted_agt, ~unstandardise_deaths_averted(.x))
  
  error_agt <- map(predicted_agt, ~error_func(test$deaths_averted_original, .x))
  
  plot <- ggplot(
    map_dfr(seq_along(predicted_agt), ~test %>% 
              ungroup() %>% 
              mutate(
      predicted = predicted_agt[[.x]],
      parameters = paste0(paste0(names(tuning_parameters[[.x]]), ": ", unlist(tuning_parameters[[.x]])), collapse = ", ")
    ))
  ) + 
    geom_abline(aes(slope = 1, intercept = 0), alpha = 0.5, linetype = "dashed") + 
    geom_point(aes(x = .data$predicted, y = .data$deaths_averted_original, colour = .data$type),
               alpha = 0.5) + 
    ggpubr::theme_pubr() + 
    facet_wrap(vars(parameters)) +
    labs(x= "Predicted", y = "Truth", colour = "Type:", title = paste0("Validation Set: ", test_index))
  #calculate error
  list(plot = plot, errors = error_agt)
})

rm(partioned_data)

#fitting plots
pdf(here::here("analysis/figures/S01_cross-validation-fits_2.pdf"))
for(fold in errors){
  print(fold$plot)
}
rm(fold)
dev.off()
#get the best set of tuning parameters
errs <- map_dbl(seq_along(tuning_parameters), function(it) mean(map_dbl(errors, ~.x$errors[[it]])))
best_params <- tuning_parameters[[which.min(errs)]]

agt_formula <- generate_formula(best_params$include_iso3c, best_params$WHO)

if(params$parallel_){
  future::plan(future::sequential)
}
```

```{r train chosen model}
#fit agt
if(params$generate_model_fits){
  fit_agt <- agtboost::gbt.train(
    y = fitting_data$deaths_averted,
    x = model.matrix(agt_formula, fitting_data),
    verbose = 100, learning_rate = best_params$learning_rate
  )
  agtboost::gbt.save(fit_agt, here::here("analysis/data/derived_data/fits/agt.agtb"))
} else {
  fit_agt <- agtboost::gbt.load(here::here("analysis/data/derived_data/fits/agt.agtb"))
}
predict_agt <- function(data){
  force(fit_agt)
  force(agt_formula)
  predict(fit_agt, model.matrix(agt_formula, data))
}
fitted_model <- function(data){
  force(predict_agt)
  predict_agt(data)
}
```

```{r estimate new deaths averted}
#keep the same variables + date so its the vaccination period
prediction_df <- fitting_data %>% 
  select(iso3c, pop, income_group, who_region, dominant_vaccine,
         all_of(names(present_vaccines)), contains("original")) %>% 
  select(!contains("deaths")) %>% 
  rename_with(.cols = contains("original"), .fn = function(x) stringr::str_replace(x, "_original", "")) %>% 
  select(!start_date_epidemic) %>% 
  unique() %>% 
  left_join(
    combined_df %>% 
      select(iso3c, who_excess_deaths, date) %>% 
      left_join(
        vaccination_start_dates,
        by = "iso3c"
      ) %>% 
      #format to bring in line with values used in the economist fitting
      mutate(who_excess_deaths = if_else(
        who_excess_deaths < 0,
        0,
        who_excess_deaths
      )) %>% 
      #split into pre/post vaccination deaths
      group_by(iso3c) %>% 
      summarise(
        deaths_non_vaccine = sum(who_excess_deaths[date < start_date_vaccination]),
        deaths_vaccine = sum(who_excess_deaths[date >= start_date_vaccination])
      ),
    by = c("iso3c")
  ) %>% #add epidemic start dates
  left_join(
    combined_df %>% 
      select(iso3c, who_excess_deaths, date) %>% 
      group_by(iso3c) %>% 
      arrange(date) %>% 
      filter(who_excess_deaths > 0) %>% 
      summarise(
        start_date_epidemic = as.numeric(min(date))
      ),
    by = c("iso3c")
  ) %>% 
  ungroup() %>% 
  #drop countries with no predicted epidemic
  filter(
    !is.na(start_date_epidemic)
  ) %>% 
  mutate(
    #set per capita
    deaths_vaccine = deaths_vaccine/pop,
    deaths_non_vaccine = deaths_non_vaccine/pop,
    deaths_averted = 1 #temp
  ) %>% 
  #standardise
  standardise_df() %>% 
  select(!deaths_averted_original)

countries_no_epidemic <- setdiff(unique(fitting_data$iso3c), prediction_df$iso3c)

#generate predictions
estimated_deaths_averted <- tibble(
  iso3c = prediction_df$iso3c,
  date = prediction_df$date,
  who = fitted_model(prediction_df) %>% 
  unstandardise_deaths_averted() %>% 
  `*`(prediction_df$pop)
)
```

```{r summarise deaths}
#reported deaths
iso3cs <- prediction_df$iso3c
names(iso3cs) <- iso3cs
if(params$gather_raw_data){
  reported_deaths <- map_dfr(
    iso3cs, .id = "iso3c",
    function(iso3c){
      #read model fit from github
      dir.create(here::here("temp"))
      exists <- tryCatch(
      download.file(
        paste0("https://github.com/mrc-ide/covid-vaccine-impact-orderly/blob/main/data/reported_deaths/model_fits/", iso3c, ".Rds?raw=true"),
        here::here("temp/fit_reported.rds"),
        mode = "wb"
      ), error = function(e){NULL})
      if(!is.null(exists)){
        model_fit <- readRDS(
        here::here("temp/fit_reported.rds")
      )
      tibble(
        `Reported Deaths` = sum(model_fit$pmcmc_results$inputs$data$deaths)
      )
      }
    })
  saveRDS(reported_deaths, here::here("analysis/data/raw_data/reported_model_deaths.Rds"))
  unlink(here::here("temp"), recursive = TRUE)
} else {
  reported_deaths <- readRDS(here::here("analysis/data/raw_data/reported_model_deaths.Rds"))
}
#economist deaths
if(params$gather_raw_data){
  economist_deaths <- map_dfr(
    iso3cs, .id = "iso3c",
    function(iso3c){
      #read model fit from github
      dir.create(here::here("temp"))
      exists <- tryCatch(
      download.file(
        paste0("https://github.com/mrc-ide/covid-vaccine-impact-orderly/blob/main/data/excess_mortality/model_fits/", iso3c, ".Rds?raw=true"),
        here::here("temp/fit_excess.rds"),
        mode = "wb"
      ), error = function(e){NULL})
      if(!is.null(exists)){
      model_fit <- readRDS(
        here::here("temp/fit_excess.rds")
      )
      tibble(
        `Economist Deaths` = sum(model_fit$pmcmc_results$inputs$data$deaths)
      )
      }
    })
  saveRDS(economist_deaths, here::here("analysis/data/raw_data/economst_model_deaths.Rds"))
  unlink(here::here("temp"), recursive = TRUE)
} else {
  economist_deaths <- readRDS(here::here("analysis/data/raw_data/economst_model_deaths.Rds"))
}
#who deaths
who_deaths <- combined_df %>% 
  select(iso3c, who_excess_deaths, date) %>%
  filter(iso3c %in% prediction_df$iso3c) %>% 
  #format to bring in line with other values used
  mutate(who_excess_deaths = if_else(
    who_excess_deaths < 0,
    0,
    who_excess_deaths
  )) %>% 
  group_by(iso3c) %>% 
  summarise(
    `WHO Deaths` = sum(who_excess_deaths)
  )

deaths <- full_join(
  reported_deaths, economist_deaths, by = "iso3c"
) %>% 
  full_join(
    who_deaths, by = "iso3c"
  )

rm(reported_deaths, economist_deaths, who_deaths, iso3cs)
```

```{r produce summary tables}
#format economist and reported estimates
fitted_deaths_averted <- deaths_averted %>% 
      select(!deaths) %>% 
      pivot_wider(names_from = type, values_from = deaths_averted) %>% 
      group_by(iso3c, replicate) %>% 
      summarise(
        economist = sum(excess, na.rm = TRUE),
        reported = sum(reported, na.rm = TRUE),
        .groups = "drop"
      )
#create per country summary csv
format_number <- function(x){
  case_when(x >= 10000 ~ format(signif(x, digits = 4), scientific = FALSE, digits = 4, big.mark = ","),
                x >= 10 ~ format(round(x, -1), big.mark = ","),
                TRUE ~ format(round(x), big.mark = ","))
}
format_model_est <- function(x){
  if(all(is.na(x))){
    "-"
  } else {
    paste0(format_number(median(x)), " (",
                                               format_number(quantile(x, 0.025)),
                                               ", ", format_number(quantile(x, 0.975)),
                                               ")")
  }
}
write_csv(
  estimated_deaths_averted %>% 
    group_by(iso3c) %>% 
    summarise(
      `WHO Deaths Averted (Predictive Model)` = format_number(sum(who))
    ) %>% 
    full_join(
      fitted_deaths_averted %>% 
        group_by(iso3c) %>% 
        summarise(
          `Economist Deaths Averted (Disease Model)` = format_model_est(economist),
          `Reported Deaths Deaths Averted (Disease Model)` = format_model_est(reported)
        ),
      by = "iso3c"
    ) %>% 
    full_join(deaths %>% 
                mutate(across(!iso3c, ~format_number(.x))), by = "iso3c") %>% 
    mutate(Country = countrycode::countrycode(iso3c, "iso3c", "country.name")) %>% 
    select(Country, `WHO Deaths Averted (Predictive Model)`, `WHO Deaths`,
           `Reported Deaths Deaths Averted (Disease Model)`, `Reported Deaths`,
           `Economist Deaths Averted (Disease Model)`, `Economist Deaths`) %>% 
    #final formatting
    mutate(
      `Reported Deaths Deaths Averted (Disease Model)` = if_else(
        is.na(`Reported Deaths`) | str_detect(`Reported Deaths`, "NA"),
        "0 (0, 0)",
        `Reported Deaths Deaths Averted (Disease Model)`
      ),
      `Reported Deaths` = if_else(
        is.na(`Reported Deaths`) | str_detect(`Reported Deaths`, "NA"),
        "0",
        `Reported Deaths`
      ),
      `Economist Deaths Averted (Disease Model)` = if_else(
        is.na(`Economist Deaths`) | str_detect(`Economist Deaths`, "NA"),
        "0 (0, 0)",
        `Economist Deaths Averted (Disease Model)`
      ),
      `Economist Deaths` = if_else(
        is.na(`Economist Deaths`) | str_detect(`Economist Deaths`, "NA"),
        "0",
        `Economist Deaths`
      ),
      `WHO Deaths Averted (Predictive Model)` = if_else(
        is.na(`WHO Deaths`) | str_detect(`WHO Deaths`, "NA"),
        "0",
        `WHO Deaths Averted (Predictive Model)`
      ),
      `WHO Deaths` = if_else(
        is.na(`WHO Deaths`) | str_detect(`WHO Deaths`, "NA"),
        "0",
        `WHO Deaths`
      )
    ),
  here::here("analysis/data/derived_data/comparison_by_country.csv")
)

#create global, regional, and income group table
summarise_predicted_by <- function(grouping, per = "total"){
  temp <- estimated_deaths_averted  %>% 
    mutate(income_group = squire.page::get_income_group(iso3c),
           who_region = squire.page::get_WHO_region(iso3c)) %>% 
    group_by_at(grouping)
  if(per == "total"){
    temp <- temp %>% 
      summarise(
      `WHO (Predictive Model)` = format_number(sum(who))
    )
  } else if(per == "capita"){
    temp <- temp %>% 
      left_join(
        fitting_data %>% 
          select(iso3c, pop),
        by = "iso3c"
      ) %>% 
      summarise(
        `Per 10k People` = signif((sum(who)/sum(pop) * 10000), digits = 4)
      )
  } else if(per == "vaccine"){
    temp <- temp %>% 
      left_join(
        fitting_data %>% 
          transmute(
            iso3c = iso3c,
            doses = second_doses_original*pop + first_doses_original*pop
          ),
        by = "iso3c"
      ) %>% 
      summarise(
        `Per 10k Vaccines` = signif((sum(who)/sum(doses) * 10000), digits = 4)
      )
  }
  if(!is.null(grouping)){
    temp %>% 
      mutate(
        across(all_of(grouping),
               ~paste0("  ", as.character(.x)),
               .names = " ")
      ) %>% 
      select(!all_of(grouping))
  } else {
    temp %>% 
      mutate(
        ` ` = "Worldwide"
      )
  }
}
summarise_deaths_by <- function(grouping){
  temp <- deaths %>% 
    mutate(income_group = squire.page::get_income_group(iso3c),
           who_region = squire.page::get_WHO_region(iso3c)) %>% 
    group_by_at(grouping) %>% 
    summarise(
      across(c(`Reported Deaths`, `Economist Deaths`, `WHO Deaths`), ~format_number(sum(.x, na.rm = TRUE)))
    )
  if(!is.null(grouping)){
    temp %>% 
      mutate(
        across(all_of(grouping),
               ~paste0("  ", as.character(.x)),
               .names = " ")
      ) %>% 
      select(!all_of(grouping))
  } else {
    temp %>% 
      mutate(
        ` ` = "Worldwide"
      )
  }
}
summarise_fitted_by <- function(grouping){
  temp <- fitted_deaths_averted %>% 
    mutate(income_group = squire.page::get_income_group(iso3c),
           who_region = squire.page::get_WHO_region(iso3c)) %>% 
    group_by_at(grouping)
  #randomly choose 2000 replicate combinations
  temp <- map_dfr(seq_len(2000), function(it){
    iso3cs <- unique(temp$iso3c)
    names(iso3cs) <- iso3cs
    reps <- unique(temp$replicate)
    economist_reps <- map_dbl(iso3cs, ~sample(reps, 1))
    reported_reps <- map_dbl(iso3cs, ~sample(reps, 1))
    #calculate totals
    temp2 <- temp %>% 
      filter(replicate == economist_reps[iso3c]) %>% 
      summarise(economist = sum(economist, na.rm = TRUE))
    temp3 <- temp %>% 
          filter(replicate == reported_reps[iso3c]) %>% 
          summarise(reported = sum(reported, na.rm = TRUE))
    if(!is.null(grouping)){
      full_join(temp2, temp3,
        by = grouping
      )
    } else {
      cbind(temp2, temp3)
    }
  }) %>% 
    group_by_at(grouping) %>% 
    summarise(
      `Economist (Disease Model)` = format_model_est(economist),
      `Reported Deaths (Disease Model)` = format_model_est(reported)
    )
  if(!is.null(grouping)){
    temp %>% 
      mutate(
        across(all_of(grouping),
               ~paste0("  ", as.character(.x)),
               .names = " ")
      ) %>% 
      select(!all_of(grouping))
  } else {
    temp %>% 
      mutate(
        ` ` = "Worldwide"
      )
  }
}
summary_table <- 
  summarise_predicted_by(NULL) %>% 
  full_join(
    summarise_fitted_by(NULL),
    by = " "
  ) %>% 
  full_join(
    summarise_deaths_by(NULL),
    by = " "
  ) %>% 
  add_row(` ` = "Income Group:") %>% 
  rbind(summarise_predicted_by("income_group") %>% 
  full_join(
    summarise_fitted_by("income_group"),
    by = " "
  ) %>% 
  full_join(
    summarise_deaths_by("income_group"),
    by = " "
  )) %>% 
  add_row(` ` = "WHO Region:") %>% 
  rbind(summarise_predicted_by("who_region") %>% 
  full_join(
    summarise_fitted_by("who_region"),
    by = " "
  ) %>% 
  full_join(
    summarise_deaths_by("who_region"),
    by = " "
  )) %>% 
  select(` `, `WHO (Predictive Model)`, `WHO Deaths`, `Economist (Disease Model)`, `Economist Deaths`, `Reported Deaths (Disease Model)`, `Reported Deaths`)
#save
write_csv(summary_table, here::here("analysis/data/derived_data/global_summary.csv"))
```

```{r deaths averted per capita and vaccine}
measure_table <- 
  summarise_predicted_by(NULL) %>% 
          full_join(
            summarise_predicted_by(NULL, "capita"),
            by = " "
          ) %>% 
          full_join(
            summarise_predicted_by(NULL, "vaccine"),
            by = " "
          ) %>% 
  add_row(` ` = "Income Group:") %>% 
  rbind(summarise_predicted_by("income_group") %>% 
          full_join(
            summarise_predicted_by("income_group", "capita"),
            by = " "
          ) %>% 
          full_join(
            summarise_predicted_by("income_group", "vaccine"),
            by = " "
          )) %>% 
  add_row(` ` = "WHO Region:") %>% 
  rbind(summarise_predicted_by("who_region") %>% 
          full_join(
            summarise_predicted_by("who_region", "capita"),
            by = " "
          ) %>% 
          full_join(
            summarise_predicted_by("who_region", "vaccine"),
            by = " "
          )) %>% 
  rename(`Total` = `WHO (Predictive Model)`) %>% 
  relocate(` `)
write_csv(measure_table, here::here("analysis/data/derived_data/global_summary_by_measure.csv"))
```


Ideally we would refit our models to the WHO estimates and compare those results
to the original output. However, the monthly format of the WHO outputs makes them
unsuitable for use in our MCMC method. Instead we will estimate the deaths 
averted from the WHO mortality by exploring the relationship deaths averted and
the Economist values.

We model this relationship by fitting a boosted regression tree @lunde2020agtboost
to predict total deaths averted from January 2020 to the 12th of December 2021.
Our chosen features are: total deaths pre vaccination, total deaths once vaccinations
have begun, the start times of the vaccination campaign, and the total numbers
of vaccine doses given by dose. We also include the features to represent the 
varying model inputs used in the vaccine impact paper: dominant vaccine and 
vaccines reported to be used (summarised into types as in the vaccine impact paper)
to represent vaccine efficacy, hospital and ICU bed capacity, income group to
capture effects of mobility, epidemic start date (estimated for WHO estimates as
the first month with positive excess morality), date of introduction for the 
Delta and Omicron variants.

```{r, fig.cap = "Global comparison of estimated WHO deaths averted to deaths averted generated by model fits to reported COVID deaths and process Economist Excess Mortality Estimates."}
knitr::kable(summary_table)
```

```{r, fig.cap = "Global esimates of deaths averted by vaccinations by WB income group or WHO region, total, or per 10k people or vaccinations (in the primary series)."}
knitr::kable(measure_table)
```

# References 

<!-- The following line ensures the references appear here for the MS Word or HTML output files, rather than right at the end of the document (this will not work for PDF files):  -->

<div id="refs"></div>

\newpage

### Colophon

<!-- Add something about renv output? -->

This report was generated on `r Sys.time()` using the following computational environment and dependencies: 
Code is available [here](https://github.com/GBarnsley/excesscompare).

```{r colophon, cache = FALSE}
# which R packages and versions?
if ("devtools" %in% installed.packages()) devtools::session_info()
```

The current Git commit details are:

```{r}
# what commit is this file at? 
if ("git2r" %in% installed.packages() & git2r::in_repository(path = ".")) git2r::repository(here::here())  
```
